from nicegui import ui
from kubernetes import client, config
from datetime import datetime
import os

# Initialize Kubernetes client
try:
    config.load_incluster_config()
except:
    config.load_kube_config()

v1 = client.CoreV1Api()
apps_v1 = client.AppsV1Api()

# Services to monitor
SERVICES = {
    'grafana': {'port': 32000, 'deployment': 'grafana', 'namespace': 'hammerspace'},
    'prometheus': {'port': 32001, 'deployment': 'prometheus', 'namespace': 'hammerspace'},
    'loki': {'port': 32002, 'deployment': 'loki', 'namespace': 'hammerspace'},
    'vector': {'port': 32003, 'deployment': 'vector', 'namespace': 'hammerspace'},
    'csi-nfs-node': {'port': None, 'deployment': 'csi-nfs-node', 'namespace': 'kube-system', 'type': 'daemonset'}
}

def get_service_status(service_name):
    """Get status of a single service."""
    service = SERVICES[service_name]
    is_daemonset = service.get('type') == 'daemonset'
    
    status = {
        'name': service_name,
        'port': service['port'],
        'status': 'Unknown',
        'replicas': 0,
        'available_replicas': 0,
        'type': 'DaemonSet' if is_daemonset else 'Deployment',
        'last_update': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    
    try:
        if is_daemonset:
            # Handle DaemonSet
            daemonset = apps_v1.read_namespaced_daemon_set(
                name=service['deployment'],
                namespace=service['namespace']
            )
            status['replicas'] = daemonset.status.desired_number_scheduled or 0
            status['available_replicas'] = daemonset.status.number_available or 0
            status['status'] = 'Running' if status['available_replicas'] > 0 else 'Not Available'
        else:
            # Handle regular deployments
            deployment = apps_v1.read_namespaced_deployment(
                name=service['deployment'],
                namespace=service['namespace']
            )
            status['replicas'] = deployment.status.replicas or 0
            status['available_replicas'] = deployment.status.available_replicas or 0
            status['status'] = 'Running' if status['available_replicas'] > 0 else 'Not Available'
            
    except Exception as e:
        status['error'] = str(e)
        status['status'] = 'Error'
    
    return status

# Create a reference to hold all cards
service_cards = {}

def update_card(card, status):
    """Update an existing card with new status."""
    # Store the current scroll position
    scroll_y = ui.run_javascript('return window.scrollY;')
    
    # Clear the card content
    card.clear()
    
    # Recreate the card with updated status
    with card:
        create_card_content(status['name'], status)
    
    # Restore scroll position
    ui.run_javascript(f'window.scrollTo(0, {scroll_y});')

def create_card(service_name, status):
    """Create a card for a service."""
    card = ui.card()
    card.service_name = service_name  # Store service name for updates
    with card:
        create_card_content(service_name, status)
    return card

def create_card_content(service_name, status):
    """Create the content of a service card."""
    is_csi = service_name == 'csi-nfs-node'
    
    # Define card classes based on dark mode
    card_classes = 'w-96' if is_csi else 'w-80'
    card_classes += ' bg-white dark:bg-gray-800 shadow-lg hover:shadow-xl transition-shadow'
    
    # Define text classes for dark mode
    text_classes = 'text-gray-800 dark:text-gray-200'
    muted_text_classes = 'text-gray-600 dark:text-gray-400'
    
    with ui.column().classes(card_classes):
        # Header with service name and status
        with ui.row().classes('w-full justify-between items-center'):
            ui.label(service_name).classes(f'text-lg font-bold {text_classes}')
            ui.label(status['status']).classes(
                f'px-2 py-1 rounded text-white ' \
                f'{"bg-green-500" if status["status"] == "Running" else "bg-yellow-500" if status["status"] == "Not Available" else "bg-red-500"}'
            )
        
        # Service type badge
        with ui.row().classes('w-full'):
            ui.badge(status['type'], color='blue').props('dense outline')
        
        ui.separator()
        
        # Main content
        with ui.column():
            # Show different info for CSI driver
            if is_csi:
                ui.label(f"Nodes: {status['available_replicas']}/{status['replicas']}").classes(text_classes)
                
                # Try to get pod details for the service
                try:
                    service = SERVICES[service_name]
                    # For CSI driver, we need to use a different label selector
                    if service_name == 'csi-nfs-node':
                        label_selector = "app.kubernetes.io/name=csi-nfs-node"
                    else:
                        label_selector = f"app={service_name}"
                    
                    pods = v1.list_namespaced_pod(
                        namespace=service['namespace'],
                        label_selector=label_selector
                    )
                    
                    with ui.expansion('View Pods', icon='info').classes('w-full'):
                        for pod in pods.items:
                            with ui.card().classes('w-full bg-gray-50 p-2 my-1'):
                                with ui.row().classes('w-full items-center'):
                                    ui.icon('pod')
                                    ui.label(pod.metadata.name).classes('font-mono text-sm')
                                    ui.label(f"({pod.status.phase})").classes('text-xs ml-2')
                                
                                # Show node name
                                if pod.spec.node_name:
                                    with ui.row().classes('items-center ml-4'):
                                        ui.icon('computer').classes('text-sm')
                                        ui.label(pod.spec.node_name).classes('text-xs')
                
                except Exception as e:
                    ui.label(f"Pod details unavailable: {str(e)}").classes('text-xs text-orange-500')
            
            # Regular service info
            else:
                ui.label(f"Replicas: {status['available_replicas']}/{status['replicas']}").classes(text_classes)
                
                # Show port and access link if available
                if status['port']:
                    with ui.row().classes('items-center'):
                        ui.label("Access:")
                        ui.link("Open", f"http://localhost:{status['port']}")
            
            # Show any errors
            if 'error' in status:
                with ui.row().classes('items-start'):
                    ui.icon('error').classes('text-red-500 mt-1')
                    ui.label(status['error']).classes('text-red-500 text-xs')
            
            # Last update time
            ui.label(f"Last checked: {status['last_update']}").classes(f'text-xs {muted_text_classes}')

def update_all_services():
    """Update all service statuses."""
    for service_name in SERVICES:
        status = get_service_status(service_name)
        # Find and update the existing card
        for card in ui.card:
            if hasattr(card, 'service_name') and card.service_name == service_name:
                update_card(card, status)
                break

def create_dashboard():
    """Create the dashboard UI."""
    ui.page_title("Hammerspace Monitoring")
    
    # Add dark mode state
    dark_mode = ui.dark_mode()
    
    def toggle_dark():
        dark_mode.toggle()
        ui.notify(f'Dark mode: {dark_mode.value}')
    
    # Create a header
    with ui.header().classes('justify-between items-center'):
        with ui.row().classes('items-center'):
            ui.label('Hammerspace Monitoring').classes('text-xl')
            ui.separator().props('vertical').classes('mx-4')
            ui.switch('Dark Mode', on_change=toggle_dark, value=dark_mode.value).props('dense')
        ui.button('Refresh', on_click=update_all_services, icon='refresh').props('flat')
    
    # Create the main content area with a dark mode background
    # Create a container for the cards
    with ui.column().classes('w-full p-4 bg-white dark:bg-gray-900 min-h-screen'):
        with ui.row().classes('w-full flex-wrap gap-4') as cards_container:
            # Initial population of cards
            for service_name in SERVICES:
                status = get_service_status(service_name)
                card = create_card(service_name, status)
                service_cards[service_name] = card
        
        # Refresh all service statuses
        def refresh():
            for service_name in SERVICES:
                status = get_service_status(service_name)
                if service_name in service_cards:
                    update_card(service_cards[service_name], status)


# Create and run the dashboard
if __name__ in {"__main__", "__mp_main__"}:
    create_dashboard()
    ui.run(port=8093, reload=True)
